# This is an example JAML file, used for basic demonstration of JAMLs capabilities and syntax.
# JAML is a flexible and powerful formatting language, used primarily for configuration files - much like TOML or YAML.
# It supports a variety of data types, including strings, integers, floats, booleans, arrays, maps and records.
# However - unlike these languages, it offers a built-in templating engine that is environment and language agnostic.
# This allows for templating and conditionals to be used directly in the configuration file.
# For these purposes, JAML makes strong use of operators, which will be explained in detail in this file.

#---------------------------------------------------------------------------------------------------------------------#

## Comments ##

# In JAML files, comments are lines that start with a hash symbol (#).
# This is an example of a comment. It can appear on its own or as part of a line.
# Multiline comments are not implemented in JAML, but can be achieved by simply using multiple single-line comments.

#---------------------------------------------------------------------------------------------------------------------#

## Constants, Variables, and Auxiliaries ##

# Constants are fixed values that are defined once and cannot be changed throughout the config file.
# They are the most basic form of data storage in JAML, and are used to store values that are not expected to change.
# It is the safest way to store data that should not be modified, as it prevents accidental changes to the value.
# Constant assignment is done using the equals sign (=), with the constant name on the left and the value on the right.
# The equals sign stands for the constant assignment operator in JAML.

# Variables, on the other hand, are used to store data that can be referenced and manipulated later down the file.
# They are more flexible than constants, as their values can be changed at any point in the file.
# This allows for dynamic data storage, and can be combined with conditionals and templates to generate content.
# Variable assignment is done in a similar way, using a colon and equals sign (:=), also known as the walrus operator.
# The colon and equals sign (or the walrus) stands for the variable assignment operator in JAML.

# Auxiliaries are temporary variables that are used to store intermediate values during the construction of the file.
# This makes them useful for storing temporary values, or for performing calculations that are not needed later.
# Unlike Constants and Variables, Auxiliaries are discarded as the file is processed, and are not part of its output.
# Auxiliary assignment is done using the tilde sign (~), with the auxiliary name on the left and the value on the right.
# The tilde stands for the auxiliary assignment operator in JAML.

constant = 5  # constant assignment - note the usage of the equals sign
constant = 7  # this will raise an error, as constants cannot be reassigned!

variable := 5  # variable assignment - note the usage of the walrus operator
variable := 7  # this will not raise an error, as variables can be reassigned

auxiliary ~ 5  # auxiliary assignment - note the usage of the tilde sign
auxiliary ~ 7  # this will not raise an error, as auxiliaries are temporary and can be reassigned

# The output of this file will not contain the auxiliary assignment, as it is not part of the final configuration.
# e.g. upon parsing the file we will have the following output: constant → 5, variable → 7

#---------------------------------------------------------------------------------------------------------------------#

## Data Types ##

# JAML supports a variety of data types, which can be used to store different kinds of information.
# The simple data types are character, string, integer, float, complex, boolean and null.
# These data types are used to store individual values, and can be assigned to variables, constants or auxiliaries.
# The compound data types are array, map and record.
# These data types are used to store collections of values, and can be nested to create more complex data structures.


## Simple type assignments ##


character = 'a'  # character assignment - note the single quotes
# characters can be any single character, including letters, numbers, symbols and whitespace
# e.g. 'a', '1', '!', ' ', '\n', '\t', etc.

string = "Hello, World!"  # string assignment - note the double quotes
# strings can be any sequence of characters, including letters, numbers, symbols and whitespace
# e.g. "Hello, World!", "123", "!", " ", "Hello, \nWorld!", etc.

integer = 5  # integer assignment - note the lack of a decimal point
# integers can be any whole number, positive or negative, including zero
# e.g. 1, 2, 3, 0, -1, -2, -3, etc.

float = 5.0  # float assignment - note the floating point
# floats can be any number, positive or negative, including zero, with a decimal point
# e.g. 1.0, 2.0, 3.0, 0.0, -1.0, -2.0, -3.0, etc.

complex = 5+3i  # complex assignment - note the + syntax with the 'i' suffix
# complex numbers can be any number, positive or negative, including zero, with an imaginary component
# e.g. 1+2i, 3+4i, 0+1i, -1+2i, -3-4i, etc.

boolean = True  # boolean assignment - note the capitalisation
# booleans can be either True or False, and are used to represent logical values
# True is equivalent to 1, and False is equivalent to 0
# case sensitivity is important - true, false, TRUE and FALSE are not valid booleans

null = Null  # null assignment - note the capitalisation
# Null is used to represent the absence of a value, and is equivalent to None in Python or null in JavaScript
# case sensitivity is important - null, NULL, None and none are not valid nulls



## Compound type assignments ##


array = [False, True, 2, 3.0, "four", 5]  # array assignment - note the square brackets
# arrays are ordered collections of elements, which can be of any type supported by JAML
# arrays in JAML are heterogeneous - elements can be of different types
# arrays can contain any combination of strings, integers, floats, booleans, arrays, maps and records
# ["one", 2, 3.0, True, [4, 5], ["six", 7], {"eight": 9, 10: "ten"}] is a valid array

# Arrays can be indexed using square brackets notation, like so: array[0], array[1], array[2], etc.
# Array indices are zero-based, so the first element is at index 0, the second element is at index 1, and so on
# Negative indices can be used to count from the end of the array, like so: array[-1], array[-2], array[-3], etc.
# Thus, based on the above array, array[0] → False, array[1] → True, array[2] → 2, array[3] → 3.0, etc.
# Trying to access an index that does not exist (as in out of bounds) will raise an error

# Arrays can also be sliced using the colon operator, like so: array[1:3], array[:3], array[3:], etc.
# Slicing returns a new array containing the elements from the start index to the end index
# If the start index is omitted, it defaults to 0, and if the end index is omitted, it defaults to the last element
# Negative indices can be used to count from the end of the array, like so: array[-1], array[-2], array[-3], etc.
# Negative slicing can also be used, like so: array[:-1], array[-3:], array[-3:-1], etc.

# multidimensional (or "nested") arrays are supported, like so: [1, 2, [3, 4], 5]
# nested arrays can be of any depth, and can contain arrays of different lengths and types
# [1, 2, ["one", "two"], [5.0]] is a valid array, as is [1, 2, [3.0, 4.0, [True, False]], 7]

# arrays can also be empty, like so: []

# arrays can be written on multiple lines, like so (indentation is optional):
# array = [
#    "one",
#    2,
#    3.0,
#    True,
#    [
#       4,
#       5
#    ],
#    [
#       "six",
#       7
#    ],
#    {
#       "eight": 9,
#       10: "ten"
#    }
# ]


map = {"key1": "value1", 2: "value2", 3.0: 3.0, '4': True} # map assignment - note the curly brackets
# maps in JAML are key-value pairs - each key is unique, and each value is associated with a key
# keys can be strings, integers, floats or booleans, but not arrays, maps or records
# values can be any type, including strings, integers, floats, booleans, arrays, maps and records
# note the mapping operator (:) between the key and value, and the comma (,) between key-value pairs

# Maps can be indexed using square brackets notation, like so: map["key1"], map[2], map[3.0], map['4']
# Trying to access a key that does not exist will raise an error
# Thus, based on the above map, map["key1"] → "value1", map[2] → "value2", map[3.0] → 3.0, map['4'] → True

# nested maps are supported, like so: {"key": {"nested_key": "value"}}
# nested maps can be of any depth, and can contain maps of different lengths and types
# {"key1": {"nested_key1": "value1", "nested_key2": "value2"}, "key2": {"nested_key3": "value3"}} is a valid map

# maps can also be empty, like so: {}

# maps can be written on multiple lines, like so (indentation is optional):
# map = {
#   "key1": "value1",
#   "key2": "value2",
#   "key3": 3.0,
#   "key4": True
# }


record = <"key1": "value1", "key2": Null, "optional_key">  # record assignment - note the angle brackets
# records in JAML are somewhat similar to maps, but support optional keys and a different syntax
# records are defined using angle brackets, with key-value pairs separated by colons, or just keys for optional keys
# unlike maps, keys can only be strings, but values can be any type supported by JAML

# Records can be indexed using dot notation, like so: record.key1, record.key2, record.optional_key
# Like maps, trying to access a key that does not exist will raise an error
# However, since records support optional keys, trying to access a key that has no value will simply return Null
# Thus, based on the above record, record.key1 → "value1", record.key2 → Null, record.optional_key → Null

# nested records are supported, like so: <"key": <"nested_key": "value">>
# nested records can be of any depth, and can contain records of different lengths and types
# <"key1": <"nested_key1": "value1", "nested_key2">, "key2"> is a valid record

# records can also be empty, like so: <>

# records can be written on multiple lines, like so (indentation is optional):
# record = <
#   "key1": "value1",
#   "key2": Null,
#   "optional_key"
# >

#---------------------------------------------------------------------------------------------------------------------#

## Operators ##

# JAML supports a variety of operators, which can be used to perform arithmetic, logical and comparison operations.
# Operators can be used with values, literals and expressions, and can be combined to form complex statements.
# The following is a list of operators supported by JAML, along with their descriptions and examples.
# Note that operators are evaluated in order of precedence, with higher precedence operators evaluated first.
# Parentheses can be used to change the order of evaluation, and to group expressions together.
# Operators are evaluated from left to right, with the exception of the assignment operators, which are evaluated from right to left.

# Rudimentary Operators (= := ~ :) #

constant → const = 1 # constant assignment operator - assigns a value to a constant
variable → var := 1  # variable assignment operator - assigns a value to a variable
auxiliary → aux ~ 1  # auxiliary assignment operator - assigns a value to an auxiliary
mapping → {"key": "value"} or <"key": "value">  # mapping operator - maps a value to a key in a map or a record

# Indexing Operators ([ ] .) #

array_indexing → array[0]  # array indexing operator - accesses an element in an array by index
map_indexing → map["key"]  # map indexing operator - accesses a value in a map by key
record_indexing → record.key  # record indexing operator - accesses a value in a record by key

# Arithmetic Operators (+ - * / ** %) #

addition → 1 + 2  # addition operator - adds two numbers together
subtraction → 3 - 4  # subtraction operator - subtracts one number from another
multiplication → 5 * 6  # multiplication operator - multiplies two numbers together
division → 7 / 8  # division operator - divides one number by another
exponentiation → 9 ** 10  # exponentiation operator - raises one number to the power of another
modulus → 11 % 12  # modulus operator - returns the remainder of dividing one number by another

# Comparison Operators (== != > < >= <= @ ~@) #

equality → 1 == 2  # equality operator - checks if two values are equal
inequality → 3 != 4  # inequality operator - checks if two values are not equal
greater_than → 5 > 6  # greater than operator - checks if one value is greater than another
less_than → 7 < 8  # less than operator - checks if one value is less than another
greater_than_or_equal_to → 9 >= 10  # greater than or equal to operator - checks if one value is greater than or equal to another
less_than_or_equal_to → 11 <= 12  # less than or equal to operator - checks if one value is less than or equal to another
membership → element @ data  # membership operator - checks if an element is in a compound data type, like an array or map
non_membership → element ~@ data  # non-membership operator - checks if an element is not in a compound data type

# Logical Operators (& | ! ^) #

and_operator → True & False  # and operator - returns True if both values are True, else False
or_operator → True | False  # or operator - returns True if either value is True, else False
not_operator → !True  # not operator - returns True if the value is False, else False
xor_operator → True ^ False  # xor operator - returns True if one value is True and the other is False, else False

# Conditional Operator (?:) #

conditional → condition ? value_if_true : value_if_false  # conditional operator - returns one of two values based on a condition
nested_conditional → condition1 ? value_if_true1 : condition2 ? value_if_true2 : value_if_false  # nested conditional operator - returns one of multiple values based on multiple conditions

#---------------------------------------------------------------------------------------------------------------------#

## Templating ##

# JAML supports templating, which allows for the substitution of placeholders into values, based on context.
# Expressions that contain placeholders are called templates, and can be used to generate dynamic content.
# The values to substitute into placeholders are called parameters, and are passed to the template at runtime.
# Placeholders are denoted by dollar signs ($) around the parameter name, like so: $some_parameter$
# Therefore, anything enclosed within dollars is considered a placeholder, and will be replaced with a parameter value.
# To use a literal dollar sign in a template, it must be escaped with a backslash (\), like so: \$
# Placeholders can be used in any data type supported by JAML, and parameters can be of any type supported by JAML.

template_string → "Hello, $name$!"  # template string with a `name` parameter - note the dollar signs
template_integer → $number$ + 5  # template integer with a `number` parameter
template_float → $number$ + 5.0  # template float with a `number` parameter
template_complex → $real$+$imaginary$i  # template complex with `real` and `imaginary` parameters
template_boolean → $flag$  # template boolean with a `flag` parameter

template_array → [$one$, $two$, $three$, $four$, $five$]  # template array with parameters
# or alternatively:
template_array → $array$

template_map → {"key1": $value1$, "key2": $value2$, "key3": $value3$}  # template array with parameters
# or alternatively:
template_map → $map$

template_record → <"key1": $value1$, "key2": $value2$, "key3">  # template record with parameters
# or alternatively:
template_record → $record$

#---------------------------------------------------------------------------------------------------------------------#

## Conditionals ##

# JAML supports conditional statements, which allow for parameter substitution based on the evaluation of expressions.
# Conditional statements can be nested, and can contain different data types, templates and operators.
# The conditional ternary operator was introduced in the previous section, and can be used to create simple conditionals.

some_boolean_constant = $param$ ? True : False  # note the usage of a template with the conditional operator
some_integer_variable := $other_number$ ? $number$ / $other_number$ : 0  # note the usage of various operators
some_auxiliary ~ ($number$ % 2) & ($number$ > 0)? "Even Positive" : "Odd Positive"  # note the usage of various operators